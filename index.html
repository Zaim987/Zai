<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>3D Circular Panels</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: pan-y;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, panelGroup;
    let isDragging = false, lastX = 0, velocity = 0;
    let zoomedPanel = null, isSnapping = false;
    const panelCount = 8;
    const radius = 5;
    const panels = [];init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 0, 5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  panelGroup = new THREE.Group();
  scene.add(panelGroup);

  const loader = new THREE.TextureLoader();
  for (let i = 0; i < panelCount; i++) {
    const angle = (i / panelCount) * Math.PI * 2;
    const geometry = new THREE.PlaneGeometry(2, 3);
    const material = new THREE.MeshBasicMaterial({
      map: loader.load(`https://picsum.photos/300/450?random=${i+1}`),
      side: THREE.DoubleSide
    });
    const panel = new THREE.Mesh(geometry, material);
    panel.userData.angle = angle;
    panel.position.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
    panel.lookAt(0, 0, 0);
    panel.rotateY(Math.PI);
    panelGroup.add(panel);
    panels.push(panel);
  }

  renderer.domElement.addEventListener('touchstart', onTouchStart);
  renderer.domElement.addEventListener('touchmove', onTouchMove);
  renderer.domElement.addEventListener('touchend', onTouchEnd);

  renderer.domElement.addEventListener('mousedown', onTouchStart);
  renderer.domElement.addEventListener('mousemove', onTouchMove);
  renderer.domElement.addEventListener('mouseup', onTouchEnd);

  renderer.domElement.addEventListener('click', onClickPanel);
  window.addEventListener('dblclick', onDoubleClick);

  window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onTouchStart(e) {
  if (zoomedPanel || isSnapping) return;
  isDragging = true;
  lastX = getX(e);
  velocity = 0;
}

function onTouchMove(e) {
  if (!isDragging || zoomedPanel || isSnapping) return;
  const x = getX(e);
  const dx = x - lastX;
  panelGroup.rotation.y += dx * 0.005;
  velocity = dx * 0.005;
  lastX = x;
}

function onTouchEnd() {
  if (zoomedPanel || isSnapping) return;
  isDragging = false;
  snapToNearestPanel();
}

function getX(e) {
  return e.touches ? e.touches[0].clientX : e.clientX;
}

function getActivePanelIndex() {
  const step = (Math.PI * 2) / panelCount;
  const angle = ((-panelGroup.rotation.y % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
  const index = Math.round(angle / step);
  return index % panelCount;
}

function snapToNearestPanel() {
  const step = (Math.PI * 2) / panelCount;
  const targetIndex = getActivePanelIndex();
  const targetRotation = -targetIndex * step;
  isSnapping = true;

  const animateSnap = () => {
    const diff = targetRotation - panelGroup.rotation.y;
    if (Math.abs(diff) > 0.001) {
      panelGroup.rotation.y += diff * 0.1;
      requestAnimationFrame(animateSnap);
    } else {
      panelGroup.rotation.y = targetRotation;
      isSnapping = false;
    }
  };
  animateSnap();
}

function onClickPanel(event) {
  if (zoomedPanel || isSnapping) return;

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2(
    (event.clientX / window.innerWidth) * 2 - 1,
    -(event.clientY / window.innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(panels);

  if (intersects.length > 0) {
    const clicked = intersects[0].object;
    const activeIndex = getActivePanelIndex();
    const clickedIndex = panels.indexOf(clicked);
    if (clickedIndex === activeIndex) {
      zoomedPanel = clicked;
    }
  }
}

function onDoubleClick() {
  if (zoomedPanel) {
    zoomedPanel.scale.set(1, 1, 1);
    zoomedPanel.position.set(
      Math.sin(zoomedPanel.userData.angle) * radius,
      0,
      Math.cos(zoomedPanel.userData.angle) * radius
    );
    zoomedPanel.lookAt(0, 0, 0);
    zoomedPanel.rotateY(Math.PI);
    zoomedPanel = null;
  }
}

function animate() {
  requestAnimationFrame(animate);

  if (!isDragging && !zoomedPanel && !isSnapping) {
    panelGroup.rotation.y += velocity;
    velocity *= 0.95;
  }

  if (zoomedPanel) {
    const targetScale = 2.8;
    zoomedPanel.scale.lerp(new THREE.Vector3(targetScale, targetScale, 1), 0.1);

    const targetZ = camera.position.z - 2.2;
    zoomedPanel.position.z += (targetZ - zoomedPanel.position.z) * 0.1;

    velocity = 0;
  }

  renderer.render(scene, camera);
}

  </script>
</body>
</html>